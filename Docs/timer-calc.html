<!DOCTYPE html>
<html>

<head>
	<title>Timer Module</title>
	<meta charset="utf-8">
</head>

<body onload='calculateDelay()' style="background: #eee; max-width: 600px; margin: 5% auto; font-family: Verdana, sans-serif;">

	<script>
	function calculateDelay() {
		var p = parseInt(document.getElementById("form").prescaler.value);
		var r = parseInt(document.getElementById("form").rounds.value);

		if (isNaN(p) | isNaN(r) | p > 65535 | r > 65535 | p <= 0 | r <= 0) {
			document.getElementById("results").style.visibility = "hidden";
			document.getElementById("errorMsg").style.visibility = "visible";
			document.getElementById("errorMsg").innerHTML="Error: Valores numéricos entre 1 y 65535 (16 bits)";
		}
		else {
			var delay = (p+1)*r / 100E6;

			document.getElementById("results").style.visibility = "visible";
			document.getElementById("errorMsg").style.visibility = "hidden";

			document.getElementById("sValue").innerHTML=delay.toFixed(4);
			document.getElementById("msValue").innerHTML=(delay / 1E-3).toFixed(4);
			document.getElementById("usValue").innerHTML=(delay / 1E-6).toFixed(4);
			document.getElementById("nsValue").innerHTML=(delay / 1E-9).toFixed(4);

		}
	}
	</script>

	<div>
		<h1>Timer</h1>
		<p>Rango de tiempos: [20ns, 42.9490s]
		<h2>Descripción</h2>
			<h3>Registros</h3>
			<ol type="0">
			<li>ROUNDS_reg</li>
			<li>PRESCALER_reg</li>
			<li>START_reg</li>
			<li>DONE_reg</li>
			</ol>

			<h3>Descripción</h3>
			<p>El módulo contiene dos contadores de 16 bits: <em>prescaler</em>, que actúa como un divisor de frecuencia, y <em>rounds</em>, que representa la cantidad de iteraciones que se van a realizar.
			</p>
			<p>
			Regularmente, se van contando ciclos de clock hasta que transcurrieron tantos como el valor que se le cargó como referencia a <em>prescaler</em>. En ese caso se produce un desborde (<em>prescaler</em> vuelve a 0), <em>rounds</em> es incrementado en una unidad y se repite el procedimiento. Esto se realiza hasta que se realizaron <em>rounds</em> iteraciones.
			</p>
			<p>
			La señal de que terminó el tiempo de espera es mantenida en el registro <em>DONE_reg</em> (2'b11) hasta que se carguen nuevos valores en algún registro. Además, si se escribe nuevamente en el registro <em>START_reg</em> (2'b10) el timer vuelve a comenzar con los tiempos configurados previamente.
			</p>
			<p>
			Escribir en cualquier registro mientras el timer está operando hace que el mismo vuelva a 0. Además, excepto en el caso de <em>START_reg</em>, el mismo queda detenido.
			</p>

		<h2>Calculadora de tiempos</h2>
		<p>(Asumiendo f<sub>clk</sub> = 100MHz)
		<form id="form" action="" method="get">
		<table>
				<tr>
				<td><label for="rounds">Rounds</label></td>
				<td><input type="number" name="rounds" maxlength="5" value="1"
					  min="1" max="65535" onchange='calculateDelay()'></td>
				</tr>
				<tr>
				<td><label for="prescaler">Prescaler</label></td>
				<td><input type="number" name="prescaler" maxlength="5" value="1"
					 min="1" max="65535" onchange='calculateDelay()'></td>
				</tr>
		</table>
		</form>
	</div>

	<div>
		<div id="errorMsg"></div>
		<table id="results" style="text-align: right">
			<tr>
				<th><em>t<sub>Delay</sub></em></th>
				<th></th>
			</tr>
			<tr>
				<td id="sValue"></td>
				<td>s</td>
			</tr>
			<tr>
				<td id="msValue"></td>
				<td>ms</td>
			</tr>
			<tr>
				<td id="usValue"></td>
				<td>µs</td>
			</tr>
			<tr>
				<td id="nsValue"></td>
				<td>ns</td>
			</tr>
		</table>
	</div>
</body>

</html>